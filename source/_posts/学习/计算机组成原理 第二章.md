---
title: 计算机组成原理 第二章
categories: 计算机组成原理
tags: 
- 课程
cover: https://s1.ax1x.com/2023/03/05/ppEhuD0.jpg
mathjax: true
---

# 第二章：运算方法和运算器

## 2.1 数据与文字的表示方式

### 真值和机器数

数据表示需要考虑的因素：

> 1.  数据的类型
> 2.  可能遇到的数值范围
> 3.  数值精确度
> 4.  数据存储和运算的硬件代价

数据的表示格式：

> 1.  定点格式
> 2.  浮点格式

真值： 现实中真实的数值  
机器数： 计算机中用0和1组合表示的数值  
定点数：固定小数点的未至表达数值的机器数  
* 定点整数：将小数点固定在机器数的最右侧表达的整数  
* 定点小数：将小数点固定在机器数的最左侧表达的小数 

浮点数：小数点浮动表达的实数  
无符号数：只表达0和正整数的定点整数  
有符号数：表达负整数、0和正整数的定点整数  
* 符号位需要占用一个位，常用机器的最高位  
* 0表示正数，1表示负数  
* 具有原码、反码、补码、移码

### 无符号数与定点数的表示

没有符号位，使用全部字长来表示数值大小  
举例：

> 字长N=8时，编码00000000~11111111  
> 取值范围： 0~255（2<sup>8</sup>\-1）

定点表示：约定机器中所有数据的小数点位置是固定不变的。通常将数据表示成纯小数或者纯整数。  
定点数x=x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>表示如下（x<sub>0</sub>表示符号位，0正1负）  
![定点小数和顶点正数](https://img-blog.csdnimg.cn/afc38de8f86b43c5a36f7fddb7d56dbc.png)  
举例：  
![举例](https://img-blog.csdnimg.cn/cdcca528f3f445dcb7c9d839e9200da9.png)

**定点小数的取值范围**  
纯小数的表示范围为：  
x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>……x<sub>n</sub>各位均为0时最小，各位均为1时最大，x<sub>0</sub>为符号位

> 0 ≤ |x| ≤ 1 - 2<sup>-n</sup>

![举例](https://img-blog.csdnimg.cn/2ca8aa9ef1114ef98908e928bc574586.png)  
**定点整数**的表示范围：  
纯整数的表示范围为：  
x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>……x<sub>n</sub>各位均为0时最小，各位均为1时最大，x<sub>0</sub>为符号位

> 0 ≤ |x| ≤ 2<sup>n</sup> - 1  
> ![举例](https://img-blog.csdnimg.cn/80128bad07f54b6a94e18207909265ec.png)

目前计算机中多采用定点纯整数表示，因此将定点数的运算简称为**整数运算**

既然定点数有大小范围，那我们如何用定点数表示非常大的数和非常小的数呢？  
我们可以引入比例因子：  
![举例](https://img-blog.csdnimg.cn/0cb749db0389413994a4cdae51096663.png)

优点:方法简单，计算方便  
缺点:表示数字的范围有限，要表示大或小的数字必须使用很多比特  
大数量级数据的表示：  
* 定点计算机间接表示:运算前按一定的固定比例(比例因子)缩放
* 运算后再用幂方式

### 浮点数的表示方法

把一个数的有效数字和数的范围在计算机的一个存储单元中分别予以表示。  
数的小数点位置随比例因子的不同而在一定范围内自由移动。

一个十进制数N可以写成：

> N = 10<sup>e</sup>×M

则，一个R进制数N可写成：

> N = R<sup>e</sup>× M

M：尾数  
e：指数  
R：基数

**阶码和尾数**  
`阶码`：表达指数部分。用整数形式表示，指明小数点在数据中的位置，决定浮点数的**表示范围**。  
`尾数`：用定点小数表示，给出有效数字的位数，决定了浮点数的**表示精度**。

![浮点数的表示](https://s1.ax1x.com/2023/03/06/ppZ1nJJ.png)  
十进制数串的表示方法（非压缩型
）：  
![十进制数串的表示方法](https://img-blog.csdnimg.cn/dc325918f27d4850b945e771c256b56e.png)  
**BCD码**  
![BCD码](https://img-blog.csdnimg.cn/5b969734637e4a58bfc5d7ae0886c8a4.png)  
二十进制编码部分方案  
![二十进制编码部分方案](https://img-blog.csdnimg.cn/7cf7be5932fe4187b564292e827609fb.png)  
二十进制有权码：  
对于有权码，将每位的数码与相应的位权相乘，再求和，就可以得到它所代表的十进制数值。  
8421码实现加减运算时的修正规则：

> 1.  未超出9（1001），不进行修正
> 2.  超出9（1001），不超过16（10000），加6修正，使它向高一组产生进位，省去最高位。
> 3.  超出16（10000），加6修正。

**余三码**  
余三码是在8421码的基础上，把每个代码都加上0011而形成的。  
普通8421码的加法器仍能为余三码加法器直接利用，具体规则如下：

> 1.  若两个十进制数的余三码相加，如果结果不产生进位，则从所得和值减去0011，便得十进制位和的余三码。
> 2.  若两个十进制的余三码相加，如果结果有进位，则其进位正确，但仍需将所得值加上0011.才求的十进制和的余三码。

**格雷码**  
格雷码的编码规则是使相邻的两个代码，只有一个二进制的状态不同，其余三个二进制位必须有相同状态。  
优点：从一个编码变到下一个相邻编码时，只有一个位的状态发生变化，有利于保证代码变换的连续性。在模拟/数字转换和产生节拍电位等应用场合特别有用。

### 数的机器码表示

把符号位和数值位一起编码来表示相应的数。

* 原码  
* 补码  
* 反码  
* 移码

#### 原码

定点整数的原码形式为x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>（x<sub>0</sub>为符号位）  
![在这里插入图片描述](https://img-blog.csdnimg.cn/183bf68e7279486c9e48e62289d21d51.png)举例：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/86dad7279c3c46cb8b8341f5dd4f0b1a.png)定点小数的原码形式为x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>（x<sub>0</sub>为符号位）  
![在这里插入图片描述](https://img-blog.csdnimg.cn/3a1bf91679574ea4907fb7cfde14235e.png)  
举例：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/9b02a282ddec4fb38fe423d61fbc7622.png)  
原码的表示范围：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/ba8e3956a6f44b1e80d11ffebd672b0f.png)**原码总结**

1.  原码为符号位加上数的绝对值，0正1负。
2.  原码0有两个编码，+0和-0编码不同
3.  原码表示简单，易于同真值之间进行转换。
4.  原码乘除运算规则简单
5.  原码加减运算负责  
    当两数相加时，同号则相加；如果是异号则相减。而在进行减法运算时，还要比较绝对值的大小，然后大数减去小数，最后还要给结果选择符号。

#### 补码

模的概念：  
计算机中运算器、寄存器、计数器都有一定的位数，不可能容纳无限大的任意数。当运算结果超出实际的最大表示范围，就会发生溢出，此时所产生的**溢出量**就是**模**(module)。  
模定义为**一个计量器的容量**。如：一个4位的计数器它的计数值为0~15。当计数器计满15之后再加1，这个计数器就发生溢出，其溢出量为16，模等于16。定点小数的溢出量为2，即以2为模；  
一个字长为n+1位的定点整数的溢出量为2<sup>n+1</sup>,即以2<sup>n+1</sup>为模。

定点整数的补码形式：x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>（x<sub>0</sub>为符号位）  
![定点整数的补码形式](https://img-blog.csdnimg.cn/7698b812aa3d4792968763d337e2cb8d.png)  
举例：  
![举例](https://img-blog.csdnimg.cn/f5a2e96acc1f4ebba3589371b66ca175.png)

定点小数的补码形式：
![定点小数的补码形式](https://s1.ax1x.com/2023/03/10/ppnbpRI.png)

补码与真值：  
![补码与真值](https://img-blog.csdnimg.cn/02c5f6d133cf4fb18fdd660db0eb4134.png)  
![补码与真值推导](https://img-blog.csdnimg.cn/6166862f331e47559b2092e7c6b196b9.png)  
举例：  
![举例](https://img-blog.csdnimg.cn/a106f050030b4b8d97a279538253954f.png)  
定点整数的补码表示：  
有符号整数在计算机中默认采用补码。  
* 最高位表示符号，0正1负  
* 正数补码：直接表示数值大小（=原码=无符号数）  
* 负数补码：将对应的正数补码取反加1

举例：  
![举例](https://img-blog.csdnimg.cn/679e1debdd4a4eaba2074f65e692e2c3.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/082d78608bea4b9ebc426b1bb15afba4.png)  
负数求补:  
负数真值“取反加一”得到机器数补码  
负数补码“取反加一”得到负数真值

负数求补运算，等效于用带借位的0做减法

![举例](https://img-blog.csdnimg.cn/ee9e52a70c45492ba6b60b7d9bd3885a.png)  
**补码的特点**

1.  补码最高一位为符号位，0正1负
2.  补码零具有**唯一**编码
3.  补码的加减运算规则简单  
    最高位参与运算，与其他位一样对待

#### 反码

反码：二进制的各位数码0变1，1变0  
有符号整数的反码：

1.  最高位表示符号，0正1负
2.  正数反码：直接表示数值大小（=原码=补码）
3.  负数反码：**将对应正数反码取反，或者源码符号位不变其他位取反**

![反码](https://s1.ax1x.com/2023/03/10/ppnHvIH.png)  
例题：  
![例题](https://img-blog.csdnimg.cn/bbd7be2f64464893ba64b1799adde98c.png)

反码和补码的关系：
同一个负数的补码和反码只在最低有效比特上差1  
$[X]_{补}=[X]_{反}+2^{-n}$

#### 机器码右移位

原则：移位时应保持移位前后机器码的对应关系与真值移位相同
* 每右移一位，真值的绝对值减为1/2  

原码:符号位固定在最高位，左边空出的数值位补**0**
补位和反码:符号位固定在最高位，左边空出的数值位补**符号位**

例如：$[X]_{补}=1.01001110$  
    => $[X/2]_{补}=1.10100111$ 

#### 补码位数扩展

原则：扩展后真值不变
* 定点纯整数  
补码：符号位固定在最高位，左边空出的数值补**符号位**  
* 定点纯小数  
补码：右边空出的数值位补**0**

#### 移码

移码通常用于表示浮点数的阶码  
假设定点整数移码形式为e<sub>k</sub>e<sub>k-1</sub>……e<sub>2</sub>e<sub>1</sub>e<sub>0</sub>时，移码的定义是：  
![移码](https://img-blog.csdnimg.cn/70afc2a36cf9444aad2b652f515f01da.png)

计算：
* 移码的符号位x0表示的规律与原码、补码、反码**相反**
* 移码和补码**仅差符号位**

8位移码表示的机器数位数的真值在数轴上向右平移了2<sup>7</sup>\=128个位置  
![在这里插入图片描述](https://img-blog.csdnimg.cn/d07b2ff5b2c24ab6b6687cf3e0986073.png)  
举例：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/d192d53003f147448d154abd20077ce6.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/a2668cc7a6034320a9c319f6c92c77b3.png)机器码总结:

1.  正数的原码、反码、补码等于真值，只有负数才分别有不同的表示方法
2.  采用补码，减法运算可以用加法运算实现，节省硬件，目前机器中广泛采用补码表示法
3.  有些机器用原码进行存储和传送，运算时改用补码
4.  有些机器做加减法时用补码，做乘除法时用原码
5.  移码表示法主要用于表示浮点数的阶码，可以直接比较大小。表示范围和补码相同，只有最高位相反

![在这里插入图片描述](https://img-blog.csdnimg.cn/54db1f47a59c425ea4d1bac476a90f8d.png)例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e681a15e73dd417e8d1938f94cb3a50a.png)

### 浮点数的机器表示

32位单精度浮点数  
IEEE754标准：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/ceb42195cddd45edb8e71e21b7ccaec6.png)  
移码方法：  
E=e+127 将`-126 ~ +127`的范围变为正整数`1 ~ 254`

64位单精度浮点数  
IEEE754标准  
![在这里插入图片描述](https://img-blog.csdnimg.cn/6d38d54b971c4d9cbe12cb82d505c9ec.png)  
**浮点数的规格化**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/0582688c596040cb873006aeb4df1a3e.png)  
在计算机内，浮点数的尾数是纯小数，对非0值的浮点数，要求尾数的绝对值必须 ≥ 1/2 ，即尾数域的最高有效位应为1，称满足这种表示要求的浮点数为**规格化表示**  
把不满足这一表示要求的尾数，变成满足这一要求的尾数的操作过程，叫作**浮点数的规格化处理**，通过**尾数移位**和**修改阶码**实现。

**隐藏位技术**  
既然非0值浮点数的尾数数值最高位必定为1，则在保存浮点数到内存前，通过尾数左移，强行把该位去掉，用同样多的尾数位就能多存一位二进制数，有利于提高数据表示精度，称这种处理方案使用了**隐藏位技术**。

![在这里插入图片描述](https://img-blog.csdnimg.cn/66b1aa84ef40484ea62429022de4302a.png)  
当然，在取回这样的浮点数到运算器执行运算时，必须先恢复该隐藏位。

**规格化表示原则**  
尾数最高有效位为1，隐藏，并且隐藏在小数点的左边（即：1≤M<2）

![在这里插入图片描述](https://img-blog.csdnimg.cn/29dbf1f6628f449cbd13fc4c2856ca8d.png)

> **指数真值e用移码形式表示为阶码E**

32位单精度规格化浮点数的表示范围：

> E = 1(0000 0001) ~ 254(1111 1110)  
> e = -126 ~ +127  
> 表达的数据范围（绝对值）  
> 最小值：e=-126，M=0（1.M = 1）  
> 十进制表达：2<sup>-126</sup> ≈ 1.18 × 10<sup>-38</sup>  
> 最大值：e = 127， M = 11……1（23个1）  
> 1.M = 1.11……1（23个1） = 2 - 2<sup>-23</sup>  
> 十进制表示：  
> (2-2<sup>-23</sup>) × 2<sup>127</sup> ≈ 2\* 2<sup>127</sup> ≈ 3.40 × 10<sup>38</sup>

64位单精度规格化浮点数的表示范围：

> E =1 ~ 2046  
> e = -1022 ~ +1023  
> 表达的数据范围（绝对值）  
> 最小值：e=-1022，M=0（1.M = 1）  
> 十进制表达：2<sup>-1022</sup> ≈ 2.23 × 10<sup>-308</sup>  
> 最大值：e = 1023， M = 11……1（52个1）  
> 1.M = 1.11……1（52个1） = 2 - 2<sup>-52</sup>  
> 十进制表示：  
> (2-2<sup>-52</sup>) ×2<sup>1023</sup> ≈ 2 × 2<sup>1023</sup> ≈ 1.79 ×10<sup>308</sup>

各类32/64位单/双精度浮点数：

1.  真值0的机器数（机器零）

> 阶码E=0，尾数M=0  
> 正0：S=0，负0：S=1

2.  非规格化浮点数：  
    阶码E=0，尾数M≠0（E偏移量为126），真值F=（-1）<sup>S</sup>×M×2<sup>E-126</sup>
3.  规格化浮点数：  
    阶码E = 1 ~ 254（1111 1110）  
    无穷大的机器数：

> 阶码E = 全1（1111 1111），尾数M =0  
> +∞：S=0，-∞：S=1

4.  NaN(Not a Number)，不是一个数  
    阶码E = 全1，尾数M≠0

![在这里插入图片描述](https://img-blog.csdnimg.cn/e416c68fc61b45e1924d5653502b3a9e.png)

例题：

![在这里插入图片描述](https://img-blog.csdnimg.cn/362e0d3363c5493b9908ce6ae53e58c2.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/411c8fad6077482ab0530ec5f62e7f4d.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/918fa7c871674bf889aa824b8d353253.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/0f4f8e30fa9c4a7fabccc0596eb657a0.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/1ab93fa4c3fc4fcea3113a606640d4a0.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/43fbed549bba4dc0b0d0b11094d812fc.png)

## 2.2 字符串的表示方法

### 大端序和小端序

字符串是指连续的一串字符，通常占用主存中连续的多个字节，每个字节存一个字符。  
存放方式可分为小端方式和大端方式。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e6437fbb41fd4a42a20a0346c2d2133d.png)

## 2.3 汉字的表示方式

1.  汉字的输入编码：  
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/9bccec7b36214a76aa553a6ffa13aa83.png)
2.  汉字内码：  
    汉字内码是用于汉字信息的存储、检索等操作的机内代码，一般采用两个字节表示。  
    汉字内码有多种方案，常用以国标码为基础的编码例如，将国标码两字节的最高位置1后形成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4f8a44a6d51c44d8874bfcc7c59b8012.png)  
3\. 字模码  
![在这里插入图片描述](https://img-blog.csdnimg.cn/6368d8915e84474cb30152d9352abf48.png)4\. 总结：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/969b7d45625e4aaa94fa0a5b5ebd2412.png)

### Unicode实现方法

UTF-8

> 以字节为单位对Unicode进行编码>对不同范围的字符使用不同长度的编码

UTF-16

> 以16位无符号整数为单位

UTF-32

> 以32位无符号整数为单位

目前UTF-8和UTF-16被广泛使用，而UTF-32由于太浪费存储空间而很少被使用

## 2.4 校验码

1.  **校验码**：能够发现甚至纠正信息传输或存储过程中出现错误的编码
2.  **检错码**：仅能检测出错误的编码
3.  **纠错码**：能够发现并纠正错误的编码
4.  最简单且应用广泛的检错码：**奇偶校验码**
5.  **奇校验**：使包括校验位在内的数据中为1的个恒为奇数
6.  **偶校验**：使包括校验位在内的数据中为1的个数恒为偶数(包括0)
7.  只能检测出奇数个位出错的情况，**不能纠错**

例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/87bf00b991d14464ab53336332db7487.png)

## 2.5 定点加法、减法运算

### 补码加法

补码加法的公式为：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/f63e7a95d2a34f8a9c1f8bcc44be3edc.png)  
在模2<sup>n+1</sup>意义下，任意两数的补码之和等于改两数之和的补码。

例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/f995ad2536f84c75899b29d94ed40e62.png)  
**补码加法的特点：**

1.  符号位要作为数的一部分一起参加运算
2.  要在模2<sup>n+1</sup>的意义下相加，即超过模的进位要丢掉

### 补码减法

补码减法公式是：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/28584b412d284ad5bdf0db7b14259461.png)  
例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/f0449325fa094ab4854ebf29e3091b90.png)

### 溢出概念与检验方法

在定点整数机器中，n+1位数的表示范围为|X|<2<sup>n</sup>\-1  
在运算过程中如出现大于绝对值的现象，称为**溢出**  
![在这里插入图片描述](https://img-blog.csdnimg.cn/9d17381548d14a1e8b8f44cb7da6cf0c.png)  
两个正数相加，结果大于机器所能表示的最大正数，称为**正溢**  
两个负数相加，结果小于机器所能表示的最小负数，称为**负溢**

例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/9d80b297ff0b49ac91f38919418af843.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/1d27cf6e21314edab527e331a81a4fb9.png)

**溢出原因分析：**  
分析可知，当最高有效数值位的运算进位与符号位的运算进位**不一致**时，将产生运算**溢出**

进一步结论：  
当_最高有效位有进位而符号位无进位_时，产生**正溢**  
当_最高有效位无进位而符号位有进位_时，产生**负溢**

#### 溢出检测方法

#### 双符号位法

**双符号位法**，称为“变形补码”或 模2<sup>n+2</sup>补码  
可使模2<sup>n+2</sup>补码所能表示的数的范围扩大一倍  
变形补码定义为：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/a71caa4cf27a4879bd314f58e7988fc1.png)  
计算时：

1.  两个符号位都看作数码一样参加运算
2.  两数进行以2<sup>n+2</sup>为模的加法，即最高符号位上产生  
    进位要丢掉  
    采用变形补码后，如果两个数相加后，其结果的符号位出01或10两种组合时，表示发生**溢出**，最高符号位所表示的是**结果的正确符号**。

例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/095a2a9f514d45a7a0ebe9b5ee27a511.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/584ca630ce06402ca7a4d975f0457d71.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e1247e1dedd54dec97651072d8f7ef1c.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e1c3fa98f0cc428690a193ecc58a9520.png)  
变形补码的总结：

1.  当以变形补码运算，运算结果的二符号位相异时，表示溢出；相同时，表示未溢出。故溢出逻辑表达式为V=S<sub>f1</sub>⊕S<sub>f2</sub>,其中S<sub>f1</sub>和S<sub>f2</sub>分别为最高符号位和第二符号位。此逻辑表达式可用异或门实现。
2.  模2<sup>n+2</sup>补码相加的结果，不论谥出与否，最高符号位始终指示正确的符号。

#### 单符号位法

(1)当符号位无进位而最高有效位有进位时，产生**正溢**  
(2)当符号位有进位而最高有效位无进位时，产生**负溢**  
故：溢出逻辑表达式为：V=C<sub>f</sub>⊕C<sub>0</sub>  
C<sub>f</sub>为符号位产生的进位，C<sub>0</sub>为最高有效位产生的进位  
（此逻辑关系可用异或门方便地实现）

> 在定点机中，当运算结果发生溢出时，机器通过逻辑电路自动检查出溢出故障，并进行中断处理。

### 基本二进制加法 / 减法器

两个二进制数字A<sub>i</sub>，B<sub>i</sub>和一个进位输入C<sub>i</sub>相加，产生一个和输出S<sub>i</sub>，以及一个进位输出C<sub>i+1</sub>

![在这里插入图片描述](https://img-blog.csdnimg.cn/4ca48b0f6d8f457abbfda75cb4f36249.png)

#### 一位全加器

根据真值表，三个输入端和两个输出端可按如下逻辑方程进行联系：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/cfed855397a34cb1aa972da17465576c.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/7bd1842b5fc14ed3bc7a8872b2d10778.png)  
C<sub>i+1</sub>的时间延迟为2T,其中**T**被定义为相应于单级逻辑电路的单位门延迟。T通常采用一个“与”门或一个“或”门的时间延迟来作为度量单位，因此多级进位链的时间延迟可以用与或门的级数或者T的数目来计算得到。（异或门的延迟时间可以视作3T）  
![在这里插入图片描述](https://img-blog.csdnimg.cn/30ed56936c424ebba16e061664b61f6c.png)n个1位的**全加器(FA)**可级联成一个n位的**行波进位加减器**  
M为**方式控制输入线**，  
当M=0时，作加法(A+B)运算  
当M=1时，作减法(A-B)运算，转化成\[A\]<sub>补</sub> - \[-B\]<sub>补</sub>运算，  
求补过程由B反+1来实现，起始进位连接到功能方式线M上  
作减法时M=1,相当于在加法器的最低位上加1.  
单符号位法的溢出检测逻辑；当C<sub>n</sub>\=C<sub>n-1</sub>时，运算无溢出  
而当C<sub>n</sub>≠C<sub>n-1</sub>时，运算有溢出，经异或门产生溢出信号。

## 2.6定点乘法运算

### 原码并行乘法

> 本部分因为部分符号很难打出来，所以会用比较多的课件图片  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/41859d079e894d65ae4c32b7de1427fa.png)早期计算机中为了简化硬件结构，采用串行的1位乘法方案，即多次执行"加法一移位”操作来实现。这种方法并不需要很多器件。然而串行方法太慢，自从大规模集成电路问世以来，出现了各种形式的流水式阵列乘法器，它们属于并行乘法器。  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020cbcebdfd41db9b53a6a8613e5116.png)  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/eca97f89c8734d41846925e9dc50f330.png)  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/c9f5e9ae3b01440aa9b3a5c1f5ec78c8.png)  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/3d270baad7bd4116b72cf414960b7d7e.png)  
> **乘法时间分析**  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/46310008caa344828c0a3cb4130cee80.png)  
> 举例：  
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/68928d9ec32d4342889b52452341c37a.png)

### 求补电路

![在这里插入图片描述](https://img-blog.csdnimg.cn/f15e8315e21a4e56a09bad364508ac20.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/b8854335055848e0ae56bc0977350ae0.png)

### 带符号的阵列乘法器

把包括求补级的乘法器又称为**符号求补的阵列乘法器**  
在这种逻辑结构中，共**使用三个求补器**  
**两个算前求补器**，作用是：将两个操作数A和B在被不带符号的乘法阵列（核心部件）相乘以前，先变成正整数。  
**一个算后求补器**，作用是：当两个输入操作数的符号不一致时，把运算结果变成带符号的数。

![在这里插入图片描述](https://img-blog.csdnimg.cn/367ace86e370462d962b0d19bc1da7dc.png)  
**总结**  
带求补器的阵列乘法器既适用于原码乘法，也适用于间接的补码乘法。  
在原码乘法中，算前求补和算后求补都不需要，因为输入数据都是立即可用的。  
间接的补码阵列乘法需要使用三个求补器。为了完成所必需的求补与乘法操作，时间大约比原码阵列乘法增加1倍。

数据送入无符号阵列乘法器之前，将参与运算的补码数据先换为数据的绝对值，由算前求补器完成。

乘积的符号位单独形成通过异或门。

完成乘法运算后，根据乘积的符号位将两数绝对值的乘积再转换回补码的形式，得出乘积的补码，由算后求补器完成。

这种带求补器的阵列乘法器所完成的补码乘法实质上属于间接的补码乘法。

## 2.7 定点除法运算

### 原理

两个原码数相除时，商的符号由两数的符号按位异或求得，商的数值部分由两数的数值部分相除求得。

设有n位定点小数（定点整数也同样适用）：  
被除数x，其原码为\[x\]<sub>原</sub>\=X<sub>f</sub>X<sub>n-1</sub>…X<sub>1</sub>X<sub>o</sub>  
除数y,其原码为\[y\]原=y<sub>f</sub>y<sub>n-1</sub>…y<sub>1</sub>y<sub>0</sub>

则有商q = ×/y,其原码为  
\[q\]<sub>原</sub>\=(x⊕y)+(0.X<sub>n-1</sub>……x<sub>1</sub>x<sub>0</sub>/0.y<sub>n-1</sub>…y<sub>1</sub>y<sub>0</sub>)  
商的数值部分运算实质上是两个正数求商的运算

例：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/03fce35a1b8b49dd9c5510519beb0afe.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/daa38faadf3d4eff89a7a7371629622c.png)

### 恢复余数法

机器不会心算，必须先作减法，若余数为正，才知道够减；若余数为负，才知道不够减。  
不够减时必须恢复原来的余数，以便再继续往下运算。恢复原来的余数，只要当前的余数加上除数即可。但由于要恢复余数，使除法进行过程的步数不固定，因此控制比较复杂。

### 加减交替法

不恢复余数法，又称加减交替法。  
其特点是运算过程中如出现不够减，则不必恢复余数，根据余数符号，可以继续往下运算步数固定，控制简单。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/a6c98497012a4d6e89de12bd4c2a01e2.png)  
**加减交替法”除法规侧**：x/y  
(1)首先对被除数x做减除数y运算，即：+\[-y\]<sub>补</sub>；  
(2)判断余数符号，若余数为正（够减），则：商上“1”，  
除数右移1位，然后做减除数(+\[-y_2<sup>1</sup>\]<sub>补</sub>)运算；  
(3)若余数为负（不够减），则：商上"0”，  
除数右移1位，然后做加除数(+\[y_2<sup>-1</sup>\]<sub>补</sub>)运算。  
**注意**：  
在定点小数的原码除法运算中  
(1)x>0,y>0,数值均取正的小数；（符号位单独考虑）  
(2) x < y ,保证：商 q = x/y也是小数。

> # \*重点题型 除法的加减交替计算
> 
> [https://blog.csdn.net/weixin\_43889841/article/details/103653662](https://blog.csdn.net/weixin_43889841/article/details/103653662)

### 阵列除法器

早期计算机为了简化结构，硬件除法器的设计采用串行的1位除法方案。即多次执行“**减法-移位**”操作来实现，并使用计数器来控制移位次数由于串行除法器速度太慢，已被淘汰  
**阵列除法器**不仅所需的控制线路少，而且能提供令人满意的高速运算。  
阵列除法器有多种多样形式，如不**恢复余数阵列除法器**，**补码阵列除法器**等等。

#### 可控加法/减法（CAS）单元

**可控加法/减法(CAS)单元**将用于并行除法流水逻辑阵列中，它有四个输出端和四个输入端。  
当输入线P=0时，CAS作加法运算；当P=1时，CAS作减法运算  
CAS单元的输入与输出的关系可用如下一组逻辑方程来表示

![在这里插入图片描述](https://img-blog.csdnimg.cn/8919ece3f758407a8d7219c1782b001f.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/4267ec0d979349e485ac5ea68c2ec752.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/87fa7bb76bea49429a07b3782c3411be.png)

#### 不恢复余数（加减交替法）阵列除法器

假定所有被处理的数都是**正小数**  
在不恢复余数的除法阵列中，每一行所执行的操作究竟是加法还是减法，取决于前一行输出的符号与被除数的符号是否一致。当出现不够减时，部分余数相对于被除数来说要改变符号。这时应该产生一个商位“0”，除数沿对角线右移，然后加到下一行的部分余数上。当部分余数不改变它的符号时，即产生商位“1”，下一行的操作应该是减法。

![在这里插入图片描述](https://img-blog.csdnimg.cn/36fd01880cb7478a8320dfc49e76f754.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/7c8f783a04604d61be82e796c12c6d26.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/8fbf826582194b0fb7335cff678eb1f8.png)  
阵列除法器分析：  
该阵列除法器是用**CAS单元**所组成的流水阵列来实  
现的。  
一个(n+1)位除(n+1)位的加减交替除法阵列由(n-1)<sup>2</sup>个CAS单元组成，其中两个操作数（被除数与除数）都是正的。

**被除数x**是一个6位的小数（双倍长度值）：  
X =0.X<sub>1</sub>X<sub>2</sub>X<sub>3</sub>X<sub>4</sub>X<sub>5</sub>X<sub>6</sub>  
它是由顶部一行和最右边的对角线上的垂直输入线来提供

**除数y**是一个3位的小数：  
y=0.y<sub>1</sub>y<sub>2</sub>y<sub>3</sub>  
它沿对角线方向进入这个阵列  
这是因为除法中的部分余数的左移，等效的操作是余数保持固定，而将除数沿对角线右移  
**商q**是一个3位的数：  
q=0.q<sub>1</sub>q<sub>2</sub>q<sub>3</sub>  
它在阵列的左边产生  
**余数r**是一个6位的小数：  
r =0.00r<sub>3</sub>r<sub>4</sub>r<sub>5</sub>r<sub>6</sub>  
\-它在阵列的最下一行产生

最上面一行所执行的初始操作是减法，因此最上面一  
行的**控制线P固定置成"1"**  
减法是用 +\[-y\]<sub>补</sub> 运算来实现的，这时右端各CAS单元上的反馈线用作初始的进位输入  
\*\*每一行最左边的单元的进位输出决定着商的数值。\*\*将当前的商反馈到下一行，就能确定下一行的操作。进位输出信号决定下一行的操作将进行加法还是减法。

**阵列除法器的运算时间**  
对不恢复余数阵列除法器来说，在进行运算时，沿着每一行都有进位（或借位）传播，同时所有行在它们的进位链上都是串行连接。  
而每个CAS单元的延迟时间为3T单元，因此，对一个2n位除以n位的不恢复余数阵列除法器来说，单元的数量为(n-1)<sup>2</sup>,考虑最大情况下的信号延迟，其除法执行时间为：  
t<sub>d</sub>\=(n-1)<sup>2</sup>×3T  
其中n为尾数位数

![在这里插入图片描述](https://img-blog.csdnimg.cn/83ae9021f5ec4e368bc6010bd3181ef9.png)

## 2.8定点运算器的组成

### 逻辑运算

逻辑数，指不带符号的二进制数

> 逻辑非、逻辑加、逻辑乘、逻辑异

**逻辑非**也称**求反**，对某数进行逻辑非运算，就是按位求反，常用变量上加一横表示：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/d332980af02842cbbb6eb1584ffb89bd.png)逻辑加，对两个数的逻辑加，就是按位求\*\*”或“\*\*

![在这里插入图片描述](https://img-blog.csdnimg.cn/45616d4582f242c5af3de6aeff85ffce.png)  
逻辑乘，就是按位求\*\*”与“\*\*  
也称逻辑与  
![在这里插入图片描述](https://img-blog.csdnimg.cn/cbd2cfb1a78d47dab358da9b5c633f0e.png)  
逻辑异，对两数进行异或，就是按位求它们的模2和，逻辑异又称”按位加“  
![在这里插入图片描述](https://img-blog.csdnimg.cn/bb4357a854c04f17889915d12c4f7adf.png)

## 2.9行波进位的补码加法/减法器

![在这里插入图片描述](https://img-blog.csdnimg.cn/4326eeeac4334576beff34aabce101bd.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/6856f5cdb13749df8289b539d414b813.png)

## 2.10ALU的基本思想

本部分可先参考：  
[ALU](https://blog.csdn.net/weixin_37641832/article/details/88704885)  
[ALU2](https://blog.csdn.net/qq_43511405/article/details/105980382)

理解`74181ALU`和`74182CLA`  
以下为课件摘录，这一部分不好打字，本文章不详细讲解。

ALU:  
**算术逻辑单元**（Arithmetic&logical Unit）是中央处理器(CPU)的执行单元，是所有中央处理器的核心组成部分。

一位全加器(FA)的逻辑表达式为：

F<sub>i</sub>\=A<sub>i</sub>⊕B<sub>i</sub>⊕C<sub>i</sub>  
C<sub>i+1</sub>\=A<sub>i</sub>B<sub>i</sub>+B<sub>i</sub>C<sub>i</sub>+C<sub>i</sub>A<sub>i</sub>

将A和B先组合成由控制参数S<sub>0</sub>,S<sub>1</sub>,S<sub>2</sub>,S<sub>3</sub>控制的组合函数X<sub>i</sub>和Y<sub>i</sub>,然后再将X<sub>i</sub>,Y<sub>i</sub>和下一位进位数通过全加器进行全加。这样，不同的控制参数可以得到不同的组合函数，因而能够实现多种算术运算和逻辑运算。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/581174985f4048948495c342b97236ad.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/bf1831ab3ff64390943d0d805af45c33.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/3411af2ba4ef4fa0804a2e4e1159fec2.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/102bdd93f3e04e359f7bec5448d677ee.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e2592c674c7c41eb80d8c28e5cb5f65c.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/b611dfb1af594792a6f7da2827e978de.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/b9e49769380c41a78071a929e9f7758a.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/ead2817e63da42b089f6b331108e9d59.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/7b5ac184b8ac42c48fd486d2e6fe34c9.png)

补充：  
**算术运算操作**是用**补码**表示法来表示的`加`是指`算术加`，运算时要考虑进位  
符号“+ ”是指“逻辑加  
减法是用补码方法进行的，其中数的反码是内部产生的，而结果输出“A减B减1”，因此做减法时需在最末位产生一个强迫进位(加1)，以便产生`A减B`的结果  
`A=B`输出端可指示两个数相等，因此它与其他ALU的`A=B`输出端按“与”逻辑连接后，可以检测两个数的相等条件  
![在这里插入图片描述](https://img-blog.csdnimg.cn/62a5fb87e3674dfb9ef842591bcca930.png)

## 2.11总线

**总线**是计算机内各部件之间传送信息的公用的一组连线根据  
总线所在位置，总线分为内部总线和外部总线两类

内部总线是指CPU内各部件的连线  
外部总线是指系统总线，即CPU与存储器、I/O系统之间的连线  
按总线的逻辑结构来说，总线可分为**单向传送总线**和**双向传送总线**

单向总线，就是信息只能向一个方向传送  
双向总线，就是信息可以分两个方向传送，既可以发送数据，也可以接收数据

![在这里插入图片描述](https://img-blog.csdnimg.cn/b3f88d29d21d4c0488d8a6c3bd90b2b2.png)  
运算器包括`ALU`、`阵列乘除器`、`寄存器`、`多路开关`、`三态缓冲器`、`数据总线`等逻辑部件  
运算器的设计，主要是围绕`ALU`和`寄存器`同`数据总线`之间如何传送操作数和运算结果进行的

在决定方案时，需要考虑数据传送的方便性和操作速度，在微型机和单片机中还要考虑在硅片上制作总线的工艺。

![在这里插入图片描述](https://img-blog.csdnimg.cn/094ea459e30843c18140ecbcae9bf305.png)**单总线总结：**  
数据可以在任何两个寄存器之间，或者在任一个寄存器和ALU之间传送  
在同一时间内，只能有一个操作数放在单总线上。为了把两个操作数输入到ALU,需要分两次来做，而且还需要A,B两个缓冲寄存器  
主要缺点是**操作速度较慢**  
虽然在这种结构中，输入数据和操作结果需要**三次串行的选通**操作，但它并不会对每种指令都增加很多执行时间，只有在对全都是CPU寄存器中的两个操作数进行操作时，单总线结构的运算器才会造成一定的时间损失。但是由于它只控制一条总线，故控制电路比较简单。

![在这里插入图片描述](https://img-blog.csdnimg.cn/32a4cfbb0f474c4196a7bffffc8f2496.png)**双总线总结：**  
两个操作数同时加到ALU进行运算，只需**一次操作控制**，而且马上就可以得到运算结果

两条总线各自把其数据送至ALU的输入端。特殊寄存器分为两组，分别与一条总线交换数据。通用寄存器中的数就可进入到任一组特殊寄存器中，使**数据传送**更为灵活

ALU的输出不能直接加到总线上去。因为，当形成操作结果的输出时，两条总线都被输入数占据，因而必须在ALU输出端设置**缓冲寄存器**

假如在总线1,2和ALU输入端之间再各加一个输入缓冲寄存器，并把两个输入数先放至这两个缓冲寄存器，那么，ALU输出端就可以直接把操作结果送至总线1或总线2上去。

![在这里插入图片描述](https://img-blog.csdnimg.cn/59b86944f85945bd95522c36ae3ad8e1.png)**三总线总结：**  
ALU的输入端分别由2条总线供给，ALU的输出与第3三条总线相连。运算操作可以在一步控制内完成。  
由于ALU本身有时间延迟，所以打入输出结果的**选通脉冲**必须考虑到包括这个延迟  
**总线旁路器**，如果一个操作数不需要修改，而直接从总线2传送到总线3，可以通过控制总线旁路器把数据传出，如果一个操作数传送时需要修改，那么就借助于ALU  
三总线结构的运算器的特点是**操作时间快**

## 2.12浮点运算和浮点运算器

### 浮点加法、减法运算

![在这里插入图片描述](https://img-blog.csdnimg.cn/ca82d8969db343078d803a5f91104a8e.png)  
**步骤**  
完成浮点加减运算的操作过程大体分为四步：  
1.`0操作数`的检查  
2.比较`阶码大小`并完成`对阶`  
3.`尾数`进行加或减运算  
4.结果`规格化`并进行`舍入`处理

`0操作数`的检查  
浮点加减运算过程比定点运算过程复杂。如果判知两个操作数`x`或`y`中有一个数为0，即可得知运算结果而没有必要再进行后续的一系列操作以节省运算时间

比较`阶码大小`并完成`对阶`  
两浮点数进行加减，首先要看两数的阶码是否相同，即小数点位置是否对齐。若二数阶码相同，表示小数点是对齐的，就可以进行尾数的加减运算。若二数阶码不同，表示小数点位置没有对齐必须使二数阶码相同，这个过程叫作对阶要对阶，首先应求出两数阶码E<sub>x</sub>和E<sub>y</sub>之差，即  
△E = E<sub>x</sub> - E<sub>y</sub>

`对阶`：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e8876742bfa64491918324f5c643c254.png)`尾数`进行加或减运算  
对阶结束后，即可进行尾数的求和运算。不论加法运算还是减法运算，都按加法进行操作，其方法与定点加减法运算完全一样。

结果`规格化`![在这里插入图片描述](https://img-blog.csdnimg.cn/6cc8214cdc1940539b21bae0dfde9489.png)  
`舍入`处理  
**就近舍入**就是通常所说的“四舍五入”例如，尾数超出规定的23位的多余位数字是10010(>10000)，多余位的值超过规定的最低有效位值的一半(16)，故最低有效位应增1。若多余的5位是01111(<10000)，则简单的截尾即可。对多余的5位10000这种特殊情况：若最低有效位为0则截尾；若为1，则向上进一位使其变为0。

**朝0舍入**，朝数轴原点方向舍入，就是简单的截尾。无论尾数是正还是负，截尾都使取值的绝对值比原值的绝对值小，这种方法容易导致误差积累  
**朝+∞舍入**，对正数，只要多余位不全为0则向最低有效位进1；对负数，则是简单的截尾  
**朝-∞舍入**，对正数，只要多余位不全为0侧简单截尾；对负数，向最低有效位进1

![在这里插入图片描述](https://img-blog.csdnimg.cn/39ef797b1af04bc18e2d726a15ff3509.png)**溢出分析**

`阶码上溢`，超过了阶码可能表示的最大值的正指数值，一般将其认为是 ∞和-∞  
`阶码下溢`，超过了阶码可能表示的最小值的负指数值，一般将其认为是0  
`尾数上溢`，两个同符号尾数相加产生了最高位向上的进位，将尾数右移，阶码增1来重新对齐  
`尾数下溢`，在将尾数右移时，尾数的最低有效位从尾数域右端流出，要进行舍入处理

**浮点数的溢出是以其阶码溢出表现出来的**

例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e8901ec676d34151b4c12275eb4a2284.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/84ca21605f954ef58cb92658ede0d7b9.png)

### 浮点乘法、除法运算

![在这里插入图片描述](https://img-blog.csdnimg.cn/1bbe47cfc0084f968864bbff46370a67.png)  
步骤：  
`0操作数`检查  
`阶码`加/减操作  
`尾数`乘/除操作  
结果`规格化`及`舍入`处理

![在这里插入图片描述](https://img-blog.csdnimg.cn/186f0946310d4f138622f51256b759c5.png)  
尾数的运算：

**第一种简单方法**是，无条件地丢掉正常尾数最低位之后的全部数值。这种办法被称为**截断处理**，好处是处理简单，缺点是影响结果的精度。  
**第二种简单办法**是，运算过程中保留右移中移出的若干高位的值，最后再按某种规则用这些位上的值修正尾数，这种处理方法被称为**舍入处理**。

**舍入处理**  
当尾数用原码表示时：  
方法一：只要尾数的最低位为1，或移出的几位中有为1的数值位，就使最低位的值为1  
方法二：0舍1入法，即当丢失的最高位的值为1时，把这个1加到最低数值位上进行修正，否则舍去丢失的各位的值

![在这里插入图片描述](https://img-blog.csdnimg.cn/0bc90431f12a4c3e8bc0c7aabc2b02cc.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/bf570e22fc094e6fb3b266ab45b7fd07.png)

## 2.14流水线原理

为了实现流水，首先必须把输入的任务分割为一系列的子任务，使各子任务能在流水线的各个阶段并发地执行，将任务连续不断地输入流水线，从而实现了子任务的并行  
流水处理大幅度地改善了计算机的系统性能，是在计算机上实现时间并行性的一种非常经济的方法。

在流水线中，原则上要求各个阶段的处理时间都相同若某一阶段的处理时间较长，势必造成其他阶段的空转等待。因此对子任务的划分，是决定流水线性能的一个关键因素，它取决于操作部分的效率、所期望的处理速度，以及成本价格等假定作业T被分成k个子任务，可表达为

T={T<sub>1</sub>,T<sub>2</sub>,……T<sub>n</sub>}

各个子任务之间有一定的优先关系；若i<j,则必须在T完成以后，T才能开始工作。具有这种线性优先关系的流水线称为**线性流水线**。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/1237470a26fa450d8d29827a7e11bcda.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e17b7a41419a40f29f15daa848c326f0.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/2b37b84f2799467c9001fbf576545f85.png)  
例题：  
![在这里插入图片描述](https://img-blog.csdnimg.cn/752035f30d8e4428a1dc0cc3574e7e2c.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/e80ce86152a7499da73d95c5829ae145.png)